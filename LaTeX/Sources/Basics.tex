%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Initial Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Welcome to Costco}

The main problem we face can be broken down into a really easy to formulate but hard to answer question.
How can we order the queued tasks, so that they run in the most optimal order?
What optimal really means is a whole discussion itself not to mention search for the perfect algorithm to achieve that desired best solution.
In this chapter I will give you a quick introduction to the main terms.
In addition, I will also try to make it as easy as possible to understand by using a situation that most of us have already suffered through.

Have you ever wondered why so many people buy prebottled water? 
How they can eat those nasty snack that you despise?
Why they have the whole cart full of milk?
Maybe these question seem rather sudden they have two things in common:
One, you never get the answer to them, and two, which is the relevant part, you ask them while standing in line at a supermarket.
You ask yourself them while staring at the family of five with two shopping carts and while questioning, whether or not you should have queued at another line.
Also wouldn't it be much better if you, with your two items, went before them?
What is the best order to queue up these people?
As you can already see this is the original, simplified question just reformulated.
We are seaching for the best algorithm that arranges people at the supermarket.
Matter of fact let's just call it by its real name: policy.
In CPU-Scheduling we call the algorithms policies or disciplines.
A single customer / shopper is called a job or a process.
In the real world a process can be anything from your drivers to the web browser showing cute cat images.
A queue is a line of people waiting to get their items scanned and the cashier is the CPU.

\section{How we compare policies}

Before we dive deeper into theory, it is important to note that there is a huge difference between fairness and performance.
Fairness usually makes sure that everyone recieves the same amount of CPU time.
This kind of policy turns out to be cyclic, which usually leads to a more responsive system, because each job gets a bit of activity every so often.
On the other hand if we want to optimize for performance we should look at the so called average turnaround time.
Turnaround time is nothing more than the time that a person has to stand in line.
Therefore the average of it is the average waiting time until you exit the supermarket.

\section{First lines of code}

During the next few chapters and sections we'll assume that one knows the amount of time that a process will take to finish, also known as burst time.
Like bursting out of joy, when you finally finish the weekly shopping.
In a real world this is almost impossible\footnote{Here I mean knowning the burst time and not escaping the supermarket.}, except if you can time travel.
With this and setting aside the optimization part, one of the most straightforward policy is called first come, first served.
This is what we usually suffer through in the queue to pay.
The policy disregards how many item one has in the cart.
The only important part is the time you arrive.
The sooner the better.
In the world of computer science the policy is better refered to as First In, First Out (FIFO).
Here is a \hyperref[code:fifo]{simple python implementation}.

We save the queue of people as a python list.
If any other job joins, it will just get appended to the end.
As for the scheduling it self:
We just loop through the list until everyone is finished.

\begin{figure}[h]
\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm,
    ]{python}
  # FIFO implementation in python
  queue = [] # initialize empty queue

  # Adding a new process
  def add_process(process):
    queue.append(process)

  # Schedule the processes
  while queue != []:
    if new_process == True: # check if there is a new process
        add_process(process)
    
    next = queue.pop(0) # picks next process
    use_resource(next) # uses resources until finished
\end{minted}
\label{code:fifo}
\caption{Python: First in, First out}
\end{figure}
In this example we just assume that the use\_resource function on line 14 is already written.
Also it is important to mention that the new\_process variable is just a bool, which gets update if a new process is waiting to join the queue.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evolving Supermarket}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
