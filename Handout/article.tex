\documentclass{report}

\usepackage{titlesec}
\usepackage{titling}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage[normalem]{ulem}
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{etoolbox}
\usepackage{listings}

% sets up mdframed
\newcounter{defi}[section]\setcounter{defi}{0}
\renewcommand{\thedefi}{\arabic{section}.\arabic{defi}}
\newenvironment{defi}[2][]{%
\refstepcounter{defi}%
\ifstrempty{#1}%
{\mdfsetup{%
frametitle={%
\tikz[baseline=(current bounding box.east),outer sep=0pt]
\node[anchor=east,rectangle,fill=blue!20]
{\strut Definition~\thedefi};}}
}%
{\mdfsetup{%
frametitle={%
\tikz[baseline=(current bounding box.east),outer sep=0pt]
\node[anchor=east,rectangle,fill=blue!20]
{\strut Definition~\thedefi:~#1};}}%
}%
\mdfsetup{innertopmargin=10pt,linecolor=blue!20,%
linewidth=2pt,topline=true,%
frametitleaboveskip=\dimexpr-\ht\strutbox\relax
}
\begin{mdframed}[]\relax % Added this line
}{%
\end{mdframed} % Added this line
}

% Example usage of mdframed
% \begin{defi}[Pythagoras' theorem]{defi:pythagoras}
% In a right triangle, the square of the hypotenuse is equal to the sum of the squares % of the catheti.
% $$a^2+b^2=c^2$$
% \end{defi}

% setup listings for code blocks
% -- colors
% Define a custom color
\usepackage{color}
\definecolor{darkred}{rgb}{0.6,0.0,0.0}
\definecolor{darkgreen}{rgb}{0,0.50,0}
\definecolor{lightblue}{rgb}{0.0,0.42,0.91}
\definecolor{orange}{rgb}{0.99,0.48,0.13}
\definecolor{grass}{rgb}{0.18,0.80,0.18}
\definecolor{pink}{rgb}{0.97,0.15,0.45}

%custom style:
\lstset{
  aboveskip=1em,
  breaklines=true,
  abovecaptionskip=-6pt,
  captionpos=b,
  escapeinside={\%*}{*)},
  frame=single,
  numbers=left,
  numbersep=15pt,
  numberstyle=\tiny,
}
% 0. Basic Color Theme
\lstdefinestyle{colored}{ %
  basicstyle=\ttfamily,
  backgroundcolor=\color{white},
  commentstyle=\color{green}\itshape,
  keywordstyle=\color{blue}\bfseries\itshape,
  stringstyle=\color{red},
}
% 1. General Python Keywords List
\lstdefinelanguage{PythonPlus}[]{Python}{
  morekeywords=[1]{,as,assert,nonlocal,with,yield,self,True,False,None,} % Python builtin
  morekeywords=[2]{,__init__,__add__,__mul__,__div__,__sub__,__call__,__getitem__,__setitem__,__eq__,__ne__,__nonzero__,__rmul__,__radd__,__repr__,__str__,__get__,__truediv__,__pow__,__name__,__future__,__all__,}, % magic methods
  morekeywords=[3]{,object,type,isinstance,copy,deepcopy,zip,enumerate,reversed,list,set,len,dict,tuple,range,xrange,append,execfile,real,imag,reduce,str,repr,}, % common functions
  morekeywords=[4]{,Exception,NameError,IndexError,SyntaxError,TypeError,ValueError,OverflowError,ZeroDivisionError,}, % errors
  morekeywords=[5]{,ode,fsolve,sqrt,exp,sin,cos,arctan,arctan2,arccos,pi, array,norm,solve,dot,arange,isscalar,max,sum,flatten,shape,reshape,find,any,all,abs,plot,linspace,legend,quad,polyval,polyfit,hstack,concatenate,vstack,column_stack,empty,zeros,ones,rand,vander,grid,pcolor,eig,eigs,eigvals,svd,qr,tan,det,logspace,roll,min,mean,cumsum,cumprod,diff,vectorize,lstsq,cla,eye,xlabel,ylabel,squeeze,}, % numpy / math
}
% 2. New Language based on Python
\lstdefinelanguage{PyBrIM}[]{PythonPlus}{
  emph={d,E,a,Fc28,Fy,Fu,D,des,supplier,Material,Rectangle,PyElmt},
}
% 3. Extended theme
\lstdefinestyle{colorEX}{
  basicstyle=\ttfamily,
  backgroundcolor=\color{white},
  commentstyle=\color{darkgreen}\slshape,
  keywordstyle=\color{blue}\bfseries\itshape,
  keywordstyle=[2]\color{blue}\bfseries,
  keywordstyle=[3]\color{grass},
  keywordstyle=[4]\color{red},
  keywordstyle=[5]\color{orange},
  stringstyle=\color{darkred},
  emphstyle=\color{pink}\underbar,
}


%define "squiggly" to make red squiggly underline
\makeatletter
\def\squiggly{\bgroup \markoverwith{\textcolor{red}{\lower3.5\p@\hbox{\sixly \char58}}}\ULon}
\makeatother


% Stuff to edit.
\title{CPU-Scheduling}
\newcommand{\thesubtitle}{The Illusion of Multitasking}
\newcommand{\currentdate}{2024/25}
\author{Mark Krutzler}
\newcommand{\auinstitution}{Kantonschule Im Lee}

\titleformat{\section}
{\huge\bfseries}
{\thesection}
{0.5em}
{}[\titlerule]

\titleformat{\subsection}
{\bfseries\LARGE}
{\thesection}
{0.5em}
{}

\titleformat{\subsubsection}
{\large\bfseries}
{\thesection}
{0.5em}
{}


\renewcommand{\maketitle}{
\begin{center}


{\Huge\bfseries
\thetitle}
\vspace{0.5em}\\
{\LARGE\thesubtitle}


{\rule{0.4\textwidth}{.4pt}}

{\bfseries \theauthor}\\
\textit{\auinstitution \ --- \currentdate}
\end{center}
}

\begin{document}

\begin{titlepage}
\vspace*{\fill}
\centering
\maketitle
\vspace*{\fill}
\end{titlepage}

\tableofcontents



\part{Forewords?}

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction} % Ensure Sources appears in the TOC

We all use computers.
The modern person couldn't do half of the things that is expected from him without an instance of Windows, MacOs or any other Operating System.
We surf the web, write emails, documents and have a video call at the same time.
The question is: "How does CPU achieve all of this?" The things listed are only the parts of the OS that we come in contact with on a daily basis.
What about all the other things hidden under the hood of a graphics environment? If it comes down to doing one thing than it's fine.
The problem arises then we have multiple tasks: The CPU can only do one thing at a time and yet we all multitask on our machines.
This Black Box effect of taking multiple jobs and working on them in a proper order is what I will disect in this "Maturarbeit".

The art of scheduling tasks could seem easy for us humans.
We ?instinctively? estimate the many aspects of the task:
\begin{itemize}
\item Job: Convince our boss to give us a pay rise\\Priority: High\\Time Required: Medium (With a lot of Waiting Time)\\Effort: High (Said "No Way" last week)
\item Job: Walk the Dog\\Priority: High\\Time Required: Low\\Effort: Low
\item Job: Go to the Hairdresser\\ Priority: Low (Went last week as well)\\Time Required: High\\Effort: Low
\end{itemize}
These prediction are often highly complex and are based on previous experiences.
We also include factors like: When was the last time I did it?
In addition to all that every human plans differently based on what's important to him/her.
Still from just the priority, time required and effort, we would roughly know how to order these things.
For example I would walk the dog first, because it is a "request" made by someone else and therefore the response time should be as low as possible.
The Hairdresser can fade into the background, due to its low priority. Maybe making an appointment is a good idea though.

A computer does nothing like that. How could it? What he sees is:
\begin{itemize}
\item Job: Process 1\\Priority: Needs to be Set\\Time Required: ??? (Waiting Time: ???)\\Effort: ???
\end{itemize}
What he knows is when the task arrived and how much time he worked on it.
With this in mind the let's get to a quick introduction of the metrics, so that we know how to rate the policies that we'll look at.



\chapter*{Metrics}
\addcontentsline{toc}{chapter}{Metrics} % Ensure Sources appears in the TOC
MAYBE JUST LEAVING THIS OUT AND LOOKING AT THIS DURING A LATER TIME (WHEN THE METRICS ARE MENTIONNED OR LINK AS A FOOTNOTE?)
ALSO THIS FOLLOWS THE OSTEP WAY TOO MUCH:
We can measure different aspects of a Scheduler Policy. There is however a differentiation between fairness and performance. It is often a tradeoff between the two. For example the concept of everybody getting a same sized piece of cake is fair. However, it would be faster to give more to the fast eaters than to those who like to talk during eating. In this scenario we can't have both fairness and performance. In reality it is really difficult to predict, who'll eat faster.

\begin{defi}[Turnaround Time]{dfn:turnaround}
The turnaround time is a performance metric. It measures how long a task took to be completed from the time it arrived.
It is calculated as follows:
$$T_{Turnaround} = T_{Completion} - T_{Arrival}$$
\vspace{1em}
\end{defi}

We'll often look at the Average Turnaround time for a predetermined set of jobs.
This helps us to quantify how "efficient" a single task is handeled.
In the best case scenario a single jobs turnaround time is equivalent to the runtime of that job.
Another really important thing for us is Response Time.
We want to move our mouse around.
If we type we want the letter to appear in an instant and the Microsoft suite should start without much delay.
Of course the startup time of a program depends on many other factors, however if we never even start to work on it, it'll take a good while.


\begin{defi}[Response Time]{dfn:response}
The response time is a performance metric. It measures the responsiveness of our computer. How much time does it take until the job is run?
It is calculated as follows:
$$T_{Response} = T_{First\_Run} - T_{Arrival}$$
\vspace{1em}
\end{defi}



\part{The ABCs of CPU Scheduling}

MAYBE HERE THE METRICS PART?

\chapter{Basic Algorithms}

This chapter mainly focuses on simple policies that can be used to order processes.
Usually there are multiple simplifications added to the scenario so that it makes sense.
The policies are generally either an abstraction for though experiments or a part of a larger system.
Therefore there will be an absense of answers to common questions like: "How do we know how long a process takes until completion?"
(Actually we actually never really know how long something will take)

\section{First In, First Out (FIFO)}

Probably the most basic of them all.
The "First In, First Our" is just as the name suggests it. 
Usually we humans know it as first come, first served. 
This policies runs into problems really quickly if the discard the possibility of all tasks requiring the same amount of run time. 
A so called "Convoy Effect" takes place. 
Just imagen how annoying it is, when you're at a store and a family of five cuts into the line in front of you. 
They have two full carts loaded. You have to wait until they finish. 
In addition to that they also send back their kid to get something. 
Wouldn't it be overall much faster if they let you in front, before the cashier starts scanning the items?

\begin{lstlisting}[language=Python, style=colorEX]
# Simple implementation of FIFO in Python
list = []

# Adding a new process
def add_client(client):
  list.append(client)

# Decide which process is next
def allocate():
  next = list.pop(0)
  use_resource(next) # function that will allow "next" to use the CPU
\end{lstlisting}

As you can see the implementation is itself pretty easy.
\pagebreak

\section{Shortest Job First (SJF)}

Now the situation changes a bit. 
The infamous family of five wants to go first, however the cashier picks you first after seeing, that you only have a few items.
This is the "Shortest Job First" (SJF). 

\begin{lstlisting}[language=Python, style=colorEX]
# Simple implementation of SJF in Python

# Define client class and list
class Client:
  def __init__(self, ttc): # ttc as time to completion
    self.ttc = ttc
    # other stuff that is relevant for the client class

list = []

# Adding a new process
client = Client(ttc) 
def add_client(client): 
  list.append(client)

# Decide which process is next
def allocate():
  list.sort(key=lambda a: a.ttc) # sort according to ttc
  next = list.pop(0)
  use_resource(next) # function that will allow "next" to use the CPU
\end{lstlisting}

There are two notable changes in this code snippet, when compared to FIFO. One of them is relevant.
First, the less exiting part is that I actually took my time to write out some of the client class definition.
Second and the real difference to FIFO is that we sort the according to the time to completion. 
This means that we will choose the task with the shortest time to completion.
AT THIS PART THE KNOWLEDGE OF PROPER SORTING ALGORITHMS IS MISSING: MAYBE A REVERSE BUBBLE SORT? 
THE LIST SHOULD BE ALREADY SOMEWHAT ORDERED AND THE LAST MEMBER HAS TO BE SORTED
The only problem is when you arrive late. The scanning of products already started and you'll have to wait.
This policy is a so called non-preemptive policy.
"Non-preemptive" just means that once a task will run until it finishes.


\section{Shortest Time-to-Completion (STCF)}

\section{Round Robin (RR)}





\part{Advanced Policies}

\chapter{Multi-Level Feedback Queue}

\chapter{Lottery and Stride Scheduling}

\part{Implementations}

\chapter{My Implementation?}

\chapter{Solaris Scheduling}

\chapter{Linux 2.6 Fair Scheduler}



\part{Conclusion}

\chapter*{Sources}
\addcontentsline{toc}{chapter}{Sources} % Ensure Sources appears in the TOC

\begin{itemize}
    \item \url{https://texblog.org/2015/09/30/fancy-boxes-for-theorem-lemma-and-proof-with-mdframed/}
\end{itemize}


TODOS:
- PROPERLY LABEL IMAGES AND CODE BLOCKS

\end{document}
